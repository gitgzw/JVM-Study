##垃圾收集器与内存分配策略##

###对象已死怎么判断###
* 很多教科书书法：给对象添加一个引用计数器，每当有一个地方引用他，计数器的值就加1；当引用失效时，计数器的值就减1；任何时刻计数器都为0的对象就是不可能再被使用。
* java没有选择计数算法管理内存，因为无法解决对象相互引用时造成的问题。比如对象objA和objB都有字段instance。

    `objA.instance=objB;objB.instance=objA;`
除此之外，两个对象再无任何引用，应该被回收。
但因为相互引用着，所以导致引用计数都不为0，于是引用计数算法无法通知GC来回收他们。

###根搜索算法###

* 通过一系列的名为"GC Roots"的对象作为起始点，从这些节点向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Root没有任何引用链相连，（数据结构图中的不可达），则证明此对象是不可用的。
* 可以作为GC Roots的对象
	* 虚拟机栈中引用的对象
	* 方法区中的类静态属性引用的对象
	* 方法区中常量引用的对象
	* 本地方法栈JNI中引用的对象

###再谈引用###

* 强引用   
	* 只要强引用还存在，垃圾回收器永远不会回收被引用的对象。
* 软引用  
	* 在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围中并进行第二次回收。   SoftReference
* 弱引用
	* 只能生存到下一次垃圾收集发生之前。 WeakReference
* 虚引用
	* 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 PhantomReference

###生存还是死亡###

* 宣告一个对象死亡，至少两次标记
	* 第一次标记，对象不可达的时候，标记一次，再筛选一次，筛选是否有必要执行finalized()方法。
		* 没有覆盖finalized()，或者finalized()已经被虚拟机栈调用过，视为不必要执行。
		
	* 第二次标记   对象被判定为要执行finalized()，会被放置到F—Queue的队列中，并在稍后由一条由虚拟机自动建立的，低优先级的Finalizer线程中执行，只是触发方法，但不等待运行结束，否则F—Queue一直等待。
		* 执行finalized()方法时如果对象成功与引用链上的任何一个对象建立联系，则第二次标记时移除出即将回收的集合，“自救”成功
		* 否则，离死不远。

###回收方法区###

* 主要回收废弃常量和无用的类

###垃圾回收算法###
* 标记—清除算法
 * 标记所有需要回收的对象，在标记完成后统一回收所有的对象。**效率低，空间碎片多**


* 复制算法
 * 将内存分为大小相等的两块，每次用其中一块，当一块的内存用完了就将还存活的对象复制到另一块上面，再把已经使用过的那块内存空间一次清理掉。
 * 现在商业虚拟机这种算法回收新生代，不是一比一，而是分为一个大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间，回收时，将Eden和Survivor中还存活的对象一次性拷贝到另一块Survivor上，最后清空用到的Eden和Survivor。
 * 

* 标记—整理算法
 * 存活率低的时候使用。标记过程与“标记—清除”算法一样，但是后续不是直接对可回收对象进行清理，而是让所有存活的对象都像一端移动，然后清理掉端边界以外的内存。
 

* 分代收集算法
*根据对象的存活周期不同将内存划分为几块。一般吧java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法，比如新生代大量对象死去，少量存活，选择复制算法，老年代存活率高，没有额外空间对他进行分配担保，采用标记清理或者标记整理。

###垃圾收集器###
* Serial收集器  单线程，必须暂停其他所有工作线程，简单高效。
* ParNew收集器 多线程垃圾回收
* Parallel Scavenge收集器  达到可控制的吞吐量
* Serial Old收集器 Serial的老年代版本，标记整理算法。
* Parallel Old收集器  Parallel Scavenge的老年代版本，标记整理算法加多线程。
* CMS收集器  获取最短回收停顿时间为目标  标记清除算法
* G1收集器   给予标记整理


###内存分配与回收策略###
* 对象优先在Eden分配
* 大对象直接进入老年代，防止在Eden和亮哥Survivor区存在大量的内存拷贝
* 长期存活对象进入老年代    对象年龄计数器